# FacebookInfer

## Introduction

## [Native-platform: Java bindings for native APIs](https://github.com/gradle/native-platform)

### Issue 1

#### <ins> Error Report from Infer

```txt
native-platform/src/main/java/net/rubygrapefruit/platform/internal/TerminfoTerminal.java:203: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `TerminalOutput TerminfoTerminal.bold()` indirectly reads without synchronization from `this.boldOn`. Potentially races with write in method `TerminfoTerminal.init()`.
 Reporting because a superclass `class net.rubygrapefruit.platform.terminal.TerminalOutput` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  201.       @Override
  202.       public TerminalOutput bold() {
  203. >         if (!supportsTextAttributes()) {
  204.               return this;
  205.           }
```

#### <ins> Relevant Code

Based on the error report generated by Infer, we know that the error is associated with the following method: `bold()`.

```java
@Override
public TerminalOutput bold() {
    if (!supportsTextAttributes()) {
        return this;
    }

    synchronized (lock) {
        write(boldOn);
    }
    return this;
}
```

The error description by Infer points to line 203 of the file `TerminfoTerminal.java`, which calls the method `supportsTextAttributes()`. Hence, to trace where the error is, we looked at the method `supportsTextAttributes()`.

```java
@Override
public boolean supportsTextAttributes() {
    return boldOn != null && dim != null;
}
```

We noticed that the method `supportsTextAttributes()` reads both `boldOn` and `dim`. We then examined where `boldOn` is read and written besides `supportsTextAttributes()`. It turns out that there are two such instances. Firstly, the method `bold()` has a read access to `boldOn` when it calls `write(boldOn)`, where the `write(byte)` method is used to write a single byte to the Java OutputStream, note that this is fine with the previous read access as two simultanous reads do not lead to a data race. Secondly, the method `init()` (see attached code below) has a write access to `boldOn` in the line `boldOn = TerminfoFunctions.boldOn(result)`.

```java
@Override
protected void init() {
    synchronized (lock) {
        FunctionResult result = new FunctionResult();
        TerminfoFunctions.initTerminal(output.ordinal(), capabilities, result);
        ...
        boldOn = TerminfoFunctions.boldOn(result);
        if (result.isFailed()) {
            throw new NativeException(String.format("Could not determine bold on control sequence %s: %s", getOutputDisplay(), result.getMessage()));
        }
        dim = TerminfoFunctions.dimOn(result);
        ...
    }
}
```

Since `supportsTextAttributes()` is not synchronized, while one thread is reading whether ```boldOn``` is not null in `supportsTextAttributes()`, another thread might write ```boldOn``` in init(), leading to a data race.

#### <ins> Solution

We can implement the following solution to resolve the data race described above:

```java
@Override
public TerminalOutput bold() {
    synchronized (lock) {
        if (!supportsTextAttributes()) {
            return this;
        }
    }

    synchronized (lock) {
        write(boldOn);
    }
    return this;
}
```
In this way, we use the same lock for all read and write access of `boldOn` and hence the reading and writing the variable must occur in a mutually-exclusive manner.

### Issue 2

Seeing that `supportsTextAttributes()` also reads `dim`, we suspect that the `dim()` method, which is implemented right below `bold()`, might also have data race problems. Indeed, looking through the bug report generated by Infer, we found the following error identified by Infer.

#### <ins> Error Report from Infer

```txt
native-platform/src/main/java/net/rubygrapefruit/platform/internal/TerminfoTerminal.java:230: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `TerminalOutput TerminfoTerminal.dim()` indirectly reads without synchronization from `this.boldOn`. Potentially races with write in method `TerminfoTerminal.init()`.
 Reporting because a superclass `class net.rubygrapefruit.platform.terminal.TerminalOutput` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  228.       @Override
  229.       public TerminalOutput dim() throws NativeException {
  230. >         if (!supportsTextAttributes()) {
  231.               return this;
  232.           }
```

#### <ins> Relevant Code

```java
@Override
public TerminalOutput dim() throws NativeException {
    if (!supportsTextAttributes()) {
        return this;
    }

    synchronized (lock) {
        write(dim);
        if (bright && foreground != null) {
            write(getColor(foreground, false));
        }
        bright = false;
    }
    return this;
}
```

Not surprisingly, this error is also caused by the under-synchronization of `supportsTextAttributes()`, which we have attached below.

```java
@Override
public boolean supportsTextAttributes() {
    return boldOn != null && dim != null;
}
```

Same to the previous bug, since `supportsTextAttributes()` is not synchronized, when one thread is reading `boldOn` by calling the method `supportsTextAttributes()`, another thread could potentially write `boldOn` via the method `init()`.

#### <ins> Solution

The fix of this data race is similar to the previous one. We simply implemented synchronization in the following way so that the reads and writes of `boldOn` are accessed in a mutually-exclusive manner.

```java
@Override
public TerminalOutput dim() throws NativeException {
    synchronized (lock) {
        if (!supportsTextAttributes()) {
            return this;
        }
    }

    synchronized (lock) {
        write(dim);
        if (bright && foreground != null) {
            write(getColor(foreground, false));
        }
        bright = false;
    }
    return this;
}
```

Given that the two bugs are effectively the same, we figured that there might be better ways to implement synchronization. Instead of implementing synchronization in the `dim()` method, seeing that the data race is caused by under-synchronization of the `supportsTextAttributes()` method, our second solution to solve the dara race problem is to use synchronization directly on `supportsTextAttributes()`:

```java
public boolean supportsTextAttributes() {
    synchronized (lock) {
        return boldOn != null && dim != null;
    }
}
```
This change would eliminate the error we had previously as well. In fact, we noticed that the second fix helps reducing the number of errors in the Infer report by 2, and we suspect that this is because another method that calls `supportsTextAttributes()` also had a similar data race problem previously and is now fixed through synchronization.

Just to double check that implementing synchronization in the `supportsTextAttributes()` method directly could resolve the data race in both Issue 1 and Issue 2, we tried removing the synchronziation lock we implemented in the solution of Issue 1 and the number of errors indeed did not increase.

### Issue 3

#### <ins> Error Report from Infer

```txt
native-platform/src/main/java/net/rubygrapefruit/platform/internal/TerminfoTerminal.java:315: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `TerminalOutput TerminfoTerminal.hideCursor()` indirectly reads without synchronization from `this.hideCursor`. Potentially races with write in method `TerminfoTerminal.init()`.
 Reporting because a superclass `class net.rubygrapefruit.platform.terminal.TerminalOutput` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  313.       @Override
  314.       public TerminalOutput hideCursor() throws NativeException {
  315. >         if (!supportsCursorVisibility()) {
  316.               return this;
  317.           }
 ```
#### <ins> Relevant Code

```java
@Override
public TerminalOutput hideCursor() throws NativeException {
    if (!supportsCursorVisibility()) {
        return this;
    }

    synchronized (lock) {
        write(hideCursor);
    }
    return this;
}
```

#### <ins> Relevant Methods

```java
@Override
public boolean supportsCursorVisibility() {
    return showCursor != null && hideCursor != null;
}
```

#### <ins> Analysis

#### <ins> Solution

```java
@Override
public TerminalOutput hideCursor() throws NativeException {
    synchronized (lock) {
        if (!supportsCursorVisibility()) {
            return this;
        }
    }

    synchronized (lock) {
        write(hideCursor);
    }
    return this;
}
```

### Issue 4

#### <ins> Error Report from Infer

```txt
native-platform/src/main/java/net/rubygrapefruit/platform/internal/TerminfoTerminal.java:164: warning: THREAD_SAFETY_VIOLATION
  Read/Write race. Non-private method `boolean TerminfoTerminal.supportsCursorVisibility()` reads without synchronization from `this.hideCursor`. Potentially races with write in method `TerminfoTerminal.init()`.
 Reporting because a superclass `class net.rubygrapefruit.platform.terminal.TerminalOutput` is annotated `@ThreadSafe`, so we assume that this method can run in parallel with other non-private methods in the class (including itself).
  162.       @Override
  163.       public boolean supportsCursorVisibility() {
  164. >         return showCursor != null && hideCursor != null;
  165.       }
```

#### <ins> Relevant Code

```java
@Override
public boolean supportsCursorVisibility() {
    return showCursor != null && hideCursor != null;
}
```

#### <ins> Relevant Methods

```java
@Override
protected void init() {
    synchronized (lock) {
        FunctionResult result = new FunctionResult();
        TerminfoFunctions.initTerminal(output.ordinal(), capabilities, result);
        if (result.isFailed()) {
            throw new NativeException(String.format("Could not open terminal for %s: %s", getOutputDisplay(), result.getMessage()));
        }
        ansiTerminal = isAnsiTerminal();
        hideCursor = TerminfoFunctions.hideCursor(result);
        if (result.isFailed()) {
            throw new NativeException(String.format("Could not determine hide cursor control sequence for %s: %s", getOutputDisplay(), result.getMessage()));
        }
        showCursor = TerminfoFunctions.showCursor(result);
        if (result.isFailed()) {
            throw new NativeException(String.format("Could not determine show cursor control sequence for %s: %s", getOutputDisplay(), result.getMessage()));
        }
        ...
    }
}
```

#### <ins> Analysis

The ```init()``` method write to the variable hide-cursor. However, we also read hide-cursor if we call the ```supportsCursorVisibility()``` method. Since we need to acquire the lock ```lock``` for the ```init()``` method, we use the same lock for the ```supportsCursorVisibility()``` method.

#### <ins> Solution

```java
public boolean supportsCursorVisibility() {
    synchronized (lock) {
        return showCursor != null && hideCursor != null;
    }
}
```

## [Rx Java](https://github.com/ReactiveX/RxJava)

### Issue 5

#### <ins> Error Report from Infer

```txt
src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableCombineLatest.java:178: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void FlowableCombineLatest$CombineLatestCoordinator.cancel()` indirectly writes to field `v.produced` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  176.               cancelled = true;
  177.               cancelAll();
  178. >             drain();
  179.           }
  180.
```

#### <ins> Revelant Code

```java
@Override
public void cancel() {
    cancelled = true;
    cancelAll();
    drain();
}
```

#### <ins> Relevant Methods

```java
void drain() {
    if (getAndIncrement() != 0) {
        return;
    }

    if (outputFused) {
        drainOutput();
    } else {
        drainAsync();
    }
}
```

```java
@SuppressWarnings("unchecked")
void drainAsync() {
    final Subscriber<? super R> a = downstream;
    final SpscLinkedArrayQueue<Object> q = queue;
    int missed = 1;
    for (;;) {
        long r = requested.get();
        long e = 0L;
        while (e != r) {
            ...
            ((CombineLatestInnerSubscriber<T>)v).requestOne();
            e++;
        }
            ...
    }
}
```

```java
public void requestOne() {
    int p = produced + 1;
    if (p == limit) {
        produced = 0;
        get().request(p);
    } else {
        produced = p;
    }
}
```

#### <ins> Analysis

The report claims that "non-private method `void FlowableCombineLatest$CombineLatestCoordinator.cancel()` indirectly writes to field `v.produced` outside of synchronization." If two threads access the `produced()` method concurrently, then the value of `produced` and `p` can be overwritten.

#### <ins> Solution

```java
synchronized public void requestOne() {
    int p = produced + 1;
    if (p == limit) {
        produced = 0;
        get().request(p);
    } else {
        produced = p;
    }
}
```

### Issue 6

#### <ins> Error Report from Infer

```txt
src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableBufferBoundary.java:302: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void FlowableBufferBoundary$BufferBoundarySubscriber.drain()` writes to field `this.emitted` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  300.                   }
  301.
  302. >                 emitted = e;
  303.                   missed = addAndGet(-missed);
  304.                   if (missed == 0) {
```

#### <ins> Relevant Code

```java
void drain() {
    if (getAndIncrement() != 0) {
        return;
    }

    int missed = 1;
    long e = emitted;
    Subscriber<? super C> a = downstream;
    SpscLinkedArrayQueue<C> q = queue;

    for (;;) {
        long r = requested.get();

        while (e != r) {
            if (cancelled) {
                q.clear();
                return;
            }

            boolean d = done;
            if (d && errors.get() != null) {
                q.clear();
                errors.tryTerminateConsumer(a);
                return;
            }

            C v = q.poll();
            boolean empty = v == null;

            if (d && empty) {
                a.onComplete();
                return;
            }

            if (empty) {
                break;
            }

            a.onNext(v);
            e++;
        }

        if (e == r) {
            if (cancelled) {
                q.clear();
                return;
            }

            if (done) {
                if (errors.get() != null) {
                    q.clear();
                    errors.tryTerminateConsumer(a);
                    return;
                } else if (q.isEmpty()) {
                    a.onComplete();
                    return;
                }
            }
        }

        emitted = e;
        missed = addAndGet(-missed);
        if (missed == 0) {
            break;
        }
    }
}
```

#### <ins> Analysis

Note: Adding synchronized tag reduced the number of THREAD_SAFETY_VIOLATION from 212 to 203. This is because there are several variables (```e```, ```missed```, ```emitted```) are victims of thread violation.

#### <ins> Solution

```java
synchronized void drain() {
    ...
}
```

### Issue 7

#### <ins> Error Report from Infer

```txt
src/main/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupJoin.java:209: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void FlowableGroupJoin$GroupJoinSubscription.drain()` indirectly writes to field `up.error` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  207.                           q.clear();
  208.                           cancelAll();
  209. >                         errorAll(a);
  210.                           return;
  211.                       }
 ```

 #### <ins> Relevant Code

 ```java
void drain() {
    if (getAndIncrement() != 0) {
        return;
    }
    ...
            if (mode == LEFT_VALUE) {
                ...
                ex = error.get();
                if (ex != null) {
                    q.clear();
                    cancelAll();
                    errorAll(a);
                    return;
                }

                ...
            }
            ...
    }
}
```

#### <ins> Relevant Methods

```java
void errorAll(Subscriber<?> a) {
    Throwable ex = ExceptionHelper.terminate(error);

    for (UnicastProcessor<TRight> up : lefts.values()) {
        up.onError(ex);
    }

    lefts.clear();
    rights.clear();

    a.onError(ex);
}
```
#### <ins> Analysis

```errorAll(a)``` changes the variable ```a``` which is not thread safe.

#### <ins> Solution

```java
synchronized void errorAll(Subscriber<?> a) {
    Throwable ex = ExceptionHelper.terminate(error);

    for (UnicastProcessor<TRight> up : lefts.values()) {
        up.onError(ex);
    }

    lefts.clear();
    rights.clear();

    a.onError(ex);
}
```

### Issue 8

#### <ins> Error Report from Infer

``` txt
src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableGroupJoin.java:205: warning: THREAD_SAFETY_VIOLATION
  Unprotected write. Non-private method `void ObservableGroupJoin$GroupJoinDisposable.drain()` indirectly writes to field `up.error` outside of synchronization.
 Reporting because another access to the same memory occurs on a background thread, although this access may not.
  203.                           q.clear();
  204.                           cancelAll();
  205. >                         errorAll(a);
  206.                           return;
  207.                       }
```

#### <ins> Relevant code

```java
void drain() {
    if (getAndIncrement() != 0) {
        return;
    }

    int missed = 1;
    SpscLinkedArrayQueue<Object> q = queue;
    Observer<? super R> a = downstream;

    for (;;) {
        for (;;) {
            ...

            Throwable ex = error.get();
            if (ex != null) {
                q.clear();
                cancelAll();
                errorAll(a);
                return;
            }
     ...
    }
}
 ```

 #### <ins> Analysis

 #### <ins> Solution

 ```java
synchronized void drain() {
    if (getAndIncrement() != 0) {
        return;
    }

    int missed = 1;
    SpscLinkedArrayQueue<Object> q = queue;
    Observer<? super R> a = downstream;

    for (;;) {
        for (;;) {
            ...

            Throwable ex = error.get();
            if (ex != null) {
                q.clear();
                cancelAll();
                errorAll(a);
                return;
            }
     ...
    }
}
 ```

#### <ins> Note
the number of thread safety violation reduces from 202 to 187.

## Conclusion
